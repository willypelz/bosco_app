"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const chalk_1 = require("chalk");
const wrap = require("wrap-ansi");
const config = require("../../../../lib/config");
const common_1 = require("../../../../lib/snyk-test/common");
function formatIssuesWithRemediation(vulns, remediationInfo, options) {
    const basicVulnInfo = {};
    for (const vuln of vulns) {
        basicVulnInfo[vuln.metadata.id] = {
            title: vuln.title,
            severity: vuln.severity,
            isNew: vuln.isNew,
            name: vuln.name,
            version: vuln.version,
            fixedIn: vuln.fixedIn,
            legalInstructions: vuln.legalInstructions,
        };
    }
    const results = [chalk_1.default.bold.white('Remediation advice')];
    const upgradeTextArray = constructUpgradesText(remediationInfo.upgrade, basicVulnInfo);
    if (upgradeTextArray.length > 0) {
        results.push(upgradeTextArray.join('\n'));
    }
    const patchedTextArray = constructPatchesText(remediationInfo.patch, basicVulnInfo);
    if (patchedTextArray.length > 0) {
        results.push(patchedTextArray.join('\n'));
    }
    const unfixableIssuesTextArray = constructUnfixableText(remediationInfo.unresolved);
    if (unfixableIssuesTextArray.length > 0) {
        results.push(unfixableIssuesTextArray.join('\n'));
    }
    return results;
}
exports.formatIssuesWithRemediation = formatIssuesWithRemediation;
function getSeverityValue(severity) {
    return common_1.SEVERITIES.find((s) => s.verboseName === severity).value;
}
exports.getSeverityValue = getSeverityValue;
function constructPatchesText(patches, basicVulnInfo) {
    if (!(Object.keys(patches).length > 0)) {
        return [];
    }
    const patchedTextArray = [chalk_1.default.bold.green('\nPatchable issues:')];
    for (const id of Object.keys(patches)) {
        // todo: add vulnToPatch package name
        const packageAtVersion = `${basicVulnInfo[id].name}@${basicVulnInfo[id].version}`;
        const patchedText = `\n  Patch available for ${chalk_1.default.bold.whiteBright(packageAtVersion)}\n`;
        const thisPatchFixes = formatIssue(id, basicVulnInfo[id].title, basicVulnInfo[id].severity, basicVulnInfo[id].isNew, basicVulnInfo[id].legalInstructions, `${basicVulnInfo[id].name}@${basicVulnInfo[id].version}`);
        patchedTextArray.push(patchedText + thisPatchFixes);
    }
    return patchedTextArray;
}
function constructUpgradesText(upgrades, basicVulnInfo) {
    if (!(Object.keys(upgrades).length > 0)) {
        return [];
    }
    const upgradeTextArray = [chalk_1.default.bold.green('\nUpgradable Issues:')];
    for (const upgrade of Object.keys(upgrades)) {
        const upgradeDepTo = _.get(upgrades, [upgrade, 'upgradeTo']);
        const vulnIds = _.get(upgrades, [upgrade, 'vulns']);
        const upgradeText = `\n  Upgrade ${chalk_1.default.bold.whiteBright(upgrade)} to ${chalk_1.default.bold.whiteBright(upgradeDepTo)} to fix\n`;
        const thisUpgradeFixes = vulnIds
            .sort((a, b) => getSeverityValue(basicVulnInfo[a].severity) - getSeverityValue(basicVulnInfo[b].severity))
            .map((id) => formatIssue(id, basicVulnInfo[id].title, basicVulnInfo[id].severity, basicVulnInfo[id].isNew, basicVulnInfo[id].legalInstructions, `${basicVulnInfo[id].name}@${basicVulnInfo[id].version}`))
            .join('\n');
        upgradeTextArray.push(upgradeText + thisUpgradeFixes);
    }
    return upgradeTextArray;
}
function constructUnfixableText(unresolved) {
    if (!(unresolved.length > 0)) {
        return [];
    }
    const unfixableIssuesTextArray = [chalk_1.default.bold.white('\nIssues with no direct upgrade or patch:')];
    for (const issue of unresolved) {
        const extraInfo = issue.fixedIn && issue.fixedIn.length
            ? `\n  This issue was fixed in versions: ${chalk_1.default.bold(issue.fixedIn.join(', '))}`
            : '\n  No upgrade or patch available';
        const packageNameAtVersion = chalk_1.default.bold
            .whiteBright(`\n  ${issue.packageName}@${issue.version}\n`);
        unfixableIssuesTextArray
            .push(packageNameAtVersion +
            formatIssue(issue.id, issue.title, issue.severity, issue.isNew, issue.legalInstructions) + `${extraInfo}`);
    }
    return unfixableIssuesTextArray;
}
function formatIssue(id, title, severity, isNew, legalInstructions, vulnerableModule) {
    const severitiesColourMapping = {
        low: {
            colorFunc(text) {
                return chalk_1.default.blueBright(text);
            },
        },
        medium: {
            colorFunc(text) {
                return chalk_1.default.yellowBright(text);
            },
        },
        high: {
            colorFunc(text) {
                return chalk_1.default.redBright(text);
            },
        },
    };
    const newBadge = isNew ? ' (new)' : '';
    const name = vulnerableModule ? ` in ${chalk_1.default.bold(vulnerableModule)}` : '';
    const wrapLegalText = wrap(`${legalInstructions}`, 100);
    const formatLegalText = wrapLegalText.split('\n').join('\n    ');
    return severitiesColourMapping[severity].colorFunc(`  âœ— ${chalk_1.default.bold(title)}${newBadge} [${titleCaseText(severity)} Severity]`) + `[${config.ROOT}/vuln/${id}]` + name
        + (legalInstructions ? `${chalk_1.default.bold('\n    Legal instructions')}:\n    ${formatLegalText}` : '');
}
function titleCaseText(text) {
    return text[0].toUpperCase() + text.slice(1);
}
//# sourceMappingURL=remediation-based-format-issues.js.map